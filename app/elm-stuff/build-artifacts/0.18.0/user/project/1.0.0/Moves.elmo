var _user$project$Moves$moves = 1;
var _user$project$Moves$searchSquare = F2(
	function (board, check) {
		var res = A2(
			_elm_lang$core$List$filterMap,
			function (square) {
				return check(square) ? _elm_lang$core$Maybe$Just(square) : _elm_lang$core$Maybe$Nothing;
			},
			A2(
				_elm_lang$core$List$concatMap,
				function (a) {
					return a;
				},
				board.board));
		var _p0 = res;
		if (_p0.ctor === '::') {
			return _p0._0;
		} else {
			return {
				highlightType: _user$project$Types$None,
				pos: {ctor: '_Tuple2', _0: -1, _1: -1},
				figure: {figureType: _user$project$Types$Empty, color: _user$project$Types$NoColor, img_src: ''}
			};
		}
	});
var _user$project$Moves$calcNext = F2(
	function (vector, board) {
		var nextSquare = F2(
			function (row, col) {
				return A2(
					_user$project$Moves$searchSquare,
					board,
					function (square) {
						return _elm_lang$core$Native_Utils.eq(
							square.pos,
							{ctor: '_Tuple2', _0: row, _1: col});
					});
			});
		var _p1 = vector.next(vector.position).pos;
		var _p3 = _p1._0;
		var _p2 = _p1._1;
		return ((_elm_lang$core$Native_Utils.cmp(_p3, 7) > 0) || ((_elm_lang$core$Native_Utils.cmp(_p3, 0) < 0) || ((_elm_lang$core$Native_Utils.cmp(_p2, 7) > 0) || ((_elm_lang$core$Native_Utils.cmp(_p2, 0) < 0) || (_elm_lang$core$Native_Utils.eq(vector.blockIn, 0) || _elm_lang$core$Native_Utils.eq(
			A2(nextSquare, _p3, _p2).figure.color,
			vector.position.figure.color)))))) ? _elm_lang$core$Native_Utils.update(
			vector,
			{
				position: vector.next(vector.position),
				isBlocked: true
			}) : (((!_elm_lang$core$Native_Utils.eq(
			A2(nextSquare, _p3, _p2).figure.color,
			vector.position.figure.color)) && (!_elm_lang$core$Native_Utils.eq(
			A2(nextSquare, _p3, _p2).figure.color,
			_user$project$Types$NoColor))) ? _elm_lang$core$Native_Utils.update(
			vector,
			{
				position: vector.next(vector.position),
				blockIn: 0
			}) : _elm_lang$core$Native_Utils.update(
			vector,
			{
				position: vector.next(vector.position),
				blockIn: vector.blockIn - 1
			}));
	});
var _user$project$Moves$returnPossibleMovesHighlighted = function (board) {
	var vectors = function (square) {
		var sideVectors = F2(
			function (row, col) {
				var nextColor = A2(
					_user$project$Moves$searchSquare,
					board,
					function (sq) {
						return _elm_lang$core$Native_Utils.eq(
							sq.pos,
							{
								ctor: '_Tuple2',
								_0: _elm_lang$core$Tuple$first(square.pos) + row,
								_1: _elm_lang$core$Tuple$second(square.pos) + col
							});
					}).figure.color;
				return {
					ctor: '::',
					_0: {
						blockIn: 1,
						isBlocked: false,
						position: square,
						next: function (square) {
							return ((!_elm_lang$core$Native_Utils.eq(nextColor, square.figure.color)) && (!_elm_lang$core$Native_Utils.eq(nextColor, _user$project$Types$NoColor))) ? _elm_lang$core$Native_Utils.update(
								square,
								{
									pos: {
										ctor: '_Tuple2',
										_0: _elm_lang$core$Tuple$first(square.pos) + row,
										_1: _elm_lang$core$Tuple$second(square.pos) + col
									}
								}) : square;
						}
					},
					_1: {ctor: '[]'}
				};
			});
		var colSelect = _elm_lang$core$Tuple$second(square.pos);
		var rowSelect = _elm_lang$core$Tuple$first(square.pos);
		var forwardDistance = function () {
			var _p4 = square.figure.color;
			switch (_p4.ctor) {
				case 'Black':
					return _elm_lang$core$Native_Utils.eq(rowSelect, 1) ? 2 : 1;
				case 'White':
					return _elm_lang$core$Native_Utils.eq(rowSelect, 6) ? 2 : 1;
				default:
					return 0;
			}
		}();
		var forwardVector = function (n) {
			return {
				ctor: '::',
				_0: {
					blockIn: forwardDistance,
					isBlocked: false,
					position: square,
					next: function (square) {
						return _elm_lang$core$Native_Utils.eq(
							A2(
								_user$project$Moves$searchSquare,
								board,
								function (sq) {
									return _elm_lang$core$Native_Utils.eq(
										sq.pos,
										A2(
											_elm_lang$core$Tuple$mapFirst,
											function (x) {
												return x + n;
											},
											square.pos));
								}).figure.color,
							_user$project$Types$NoColor) ? _elm_lang$core$Native_Utils.update(
							square,
							{
								pos: A2(
									_elm_lang$core$Tuple$mapFirst,
									function (x) {
										return x + n;
									},
									square.pos)
							}) : square;
					}
				},
				_1: {ctor: '[]'}
			};
		};
		var makeVectors = function (n) {
			return A2(
				_elm_lang$core$List$repeat,
				n,
				F2(
					function (a, b) {
						return {
							blockIn: -1,
							isBlocked: false,
							position: square,
							next: function (square) {
								return _elm_lang$core$Native_Utils.update(
									square,
									{
										pos: {
											ctor: '_Tuple2',
											_0: _elm_lang$core$Tuple$first(square.pos) + a,
											_1: _elm_lang$core$Tuple$second(square.pos) + b
										}
									});
							}
						};
					}));
		};
		var _p5 = square.figure.figureType;
		switch (_p5.ctor) {
			case 'Rook':
				return A3(
					_elm_lang$core$List$map2,
					F2(
						function (vector, tupl) {
							return A2(
								vector,
								_elm_lang$core$Tuple$first(tupl),
								_elm_lang$core$Tuple$second(tupl));
						}),
					makeVectors(4),
					{
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 1, _1: 0},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: -1, _1: 0},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: 0, _1: 1},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: 0, _1: -1},
									_1: {ctor: '[]'}
								}
							}
						}
					});
			case 'Bishop':
				return A3(
					_elm_lang$core$List$map2,
					F2(
						function (vector, tupl) {
							return A2(
								vector,
								_elm_lang$core$Tuple$first(tupl),
								_elm_lang$core$Tuple$second(tupl));
						}),
					makeVectors(4),
					{
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 1, _1: 1},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: 1, _1: -1},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: -1, _1: 1},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: -1, _1: -1},
									_1: {ctor: '[]'}
								}
							}
						}
					});
			case 'Queen':
				var figura = square.figure;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					vectors(
						_elm_lang$core$Native_Utils.update(
							square,
							{
								figure: _elm_lang$core$Native_Utils.update(
									figura,
									{figureType: _user$project$Types$Rook})
							})),
					vectors(
						_elm_lang$core$Native_Utils.update(
							square,
							{
								figure: _elm_lang$core$Native_Utils.update(
									figura,
									{figureType: _user$project$Types$Bishop})
							})));
			case 'Knight':
				return A3(
					_elm_lang$core$List$map2,
					F2(
						function (vector, tupl) {
							var myVector = A2(
								vector,
								_elm_lang$core$Tuple$first(tupl),
								_elm_lang$core$Tuple$second(tupl));
							return _elm_lang$core$Native_Utils.update(
								myVector,
								{blockIn: 1});
						}),
					makeVectors(8),
					{
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: -2, _1: 1},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: -1, _1: 2},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: 1, _1: 2},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: 2, _1: 1},
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: 2, _1: -1},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: 1, _1: -2},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: -1, _1: -2},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: -2, _1: -1},
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							}
						}
					});
			case 'King':
				var figura = square.figure;
				return A2(
					_elm_lang$core$List$map,
					function (vector) {
						return _elm_lang$core$Native_Utils.update(
							vector,
							{blockIn: 1});
					},
					vectors(
						_elm_lang$core$Native_Utils.update(
							square,
							{
								figure: _elm_lang$core$Native_Utils.update(
									figura,
									{figureType: _user$project$Types$Queen})
							})));
			case 'Pawn':
				var _p6 = square.figure.color;
				switch (_p6.ctor) {
					case 'Black':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							forwardVector(1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(sideVectors, 1, 1),
								A2(sideVectors, 1, -1)));
					case 'White':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							forwardVector(-1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(sideVectors, -1, 1),
								A2(sideVectors, -1, -1)));
					default:
						return {
							ctor: '::',
							_0: {
								isBlocked: true,
								position: square,
								next: function (_p7) {
									return square;
								},
								blockIn: -1
							},
							_1: {ctor: '[]'}
						};
				}
			default:
				return {
					ctor: '::',
					_0: {
						isBlocked: true,
						position: square,
						next: function (_p8) {
							return square;
						},
						blockIn: -1
					},
					_1: {ctor: '[]'}
				};
		}
	};
	var newBoard = function () {
		var changeSquare = F2(
			function (squareList, vector) {
				return A2(
					_elm_lang$core$List$map,
					function (row) {
						return A2(
							_elm_lang$core$List$map,
							function (square) {
								return (_elm_lang$core$Native_Utils.eq(vector.position.pos, square.pos) && (!_elm_lang$core$Native_Utils.eq(
									square.pos,
									A2(
										_user$project$Moves$searchSquare,
										board,
										function (square) {
											return _elm_lang$core$Native_Utils.eq(square.highlightType, _user$project$Types$ChosenSquare);
										}).pos))) ? _elm_lang$core$Native_Utils.update(
									square,
									{highlightType: _user$project$Types$PossibleMove}) : square;
							},
							row);
					},
					squareList);
			});
		var changeBoard = F2(
			function (squareList, vector) {
				changeBoard:
				while (true) {
					if (_elm_lang$core$Native_Utils.eq(vector.isBlocked, false)) {
						var _v5 = A2(changeSquare, squareList, vector),
							_v6 = A2(_user$project$Moves$calcNext, vector, board);
						squareList = _v5;
						vector = _v6;
						continue changeBoard;
					} else {
						return squareList;
					}
				}
			});
		var vectorList = vectors(
			A2(
				_user$project$Moves$searchSquare,
				board,
				function (square) {
					return _elm_lang$core$Native_Utils.eq(square.highlightType, _user$project$Types$ChosenSquare);
				}));
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (vector, board) {
					return A2(changeBoard, board, vector);
				}),
			board.board,
			vectorList);
	}();
	return _elm_lang$core$Native_Utils.update(
		board,
		{board: newBoard});
};
var _user$project$Moves$Vector = F4(
	function (a, b, c, d) {
		return {position: a, next: b, isBlocked: c, blockIn: d};
	});
